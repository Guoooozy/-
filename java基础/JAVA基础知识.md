# JAVA基础知识

## 1.1 Java入门(基础概念与知识)

### 1.1.1 JVM,JDK,JRE概述

### JRE概述

>JVM是什么

JVM是java虚拟机，是运行字节码文件的地方，不止可以运行java程序，任何程序只要通过自己的编译器将源代码编译成合法的字节码文件（.class文件）都可以在JVM中运行。

> 字节码？字节码的好处？

JVM可理解的代码就是字节码（.class文件），不面向任何特定的处理器，只面向虚拟机。

好处：解决传统解释型语言执行效率低，保留了解释型语言可移植性的特点，使java程序运行时高效，而且字节码并不针对某种特定的机器，所以java程序无需重新编译便可以在不同操作系统的计算机上运行（平台无关性）

**平台无关性，语言无关性**

> Java程序从源代码到运行经历一下三步：

.java文件（源代码）--->.class文件---->机器可执行的二进制机器码

> .class--->机器码 这一步

①JVM类加载器首先加载字节码文件

②通过解释器逐行解释执行（相对较慢，热点代码无法得到很好的处理）

③之后引进了JIT编译器，JIT属于运行时编译，当完成第一次编译后，会将字节码文件保存下来，之后如果再次调用热点代码，就可以直接使用。

④JDK9 引入了新的编译模式AOT，是直接将字节码编译成机器码，避免了JIT预热等各方面的开销。JDK支持分层编译和AOT写作实用。但AOT编译器的便以质量无法与JIT相比

> JDK和JRE

JDK是功能齐全的Java SDK ，拥有JRE拥有的一切，还有编译器（javac）和工具（例如javadoc和jdb）。它能够创建和编译程序

JRE是java运行时环境，包括JVM，Java类库，Java命令和其他基础构建，但由于没有javac，无法用它创建新程序。

JDK是java开发运行工具包，JRE是java运行时环境。

注意：JSP部署在Web应用程序上时，虽然只是运行Java程序，但tomcat需要使用javac来编译servlet，所以应该用JDK

### 1.1.2  Java和C++区别？

- 都是面向对象语言，都支持封装，继承，多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类是单继承，C++支持多继承，但Java的接口可以多继承
- Java有GC，不需要程序员手动释放内存
- 在C语言中，字符串和字符数组最后都有一个额外的'\0'来表示结束，但Java语言中没有结束符这一概念（Java中一切皆对象，在java中，字符串对象有length属性，所以无需使用'\0'来结束）

### 1.1.3 什么是Java程序的主类 应用程序和小程序的主类有何不同？

在Java应用程序中，主类是main(),在Java小程序中，主类是继承自系统类JApplet或Applet的子类，应用程序的主类不一定是public，但小程序主类必须是public。主类是Java程序执行的入口点

### 1.1.4 import java 和 javax的区别？

最开始JavaAPI所需的包是java开头的包，javax是扩展API包，但后来Javax成为Java API的一部分，所以实际上java 和javax没有区别，是一个名字

### 1.1.5 为什么Java语言“编译与解释并存

编译型语言是指     将源代码**一次性**翻译成机器码

解释型语言是指     对源程序逐行进行解释成机器码

java语言则是，先一次性编译成.class文件，再有JVM解释成机器码，所以Java语言编译与解释并存

## 1.2 Java语法

### 1.2.1 字符型常量和字符串常量的区别

1.形式上，字符常量是单个字符，字符串常量是0个或多个字符

2.含以上，字符常量相当于一个整型值（ASCII），可以参加表达式运算，字符串常量代表一个地址值（字符串在内存中存放的位置）

3.占内存大小，在java中 字符常量占两个字节，字符串则是多个

>char 的封装类 Character 有一个成员常量 Character.SIZE 值为16，单位是bits，一个字节等于8bits ，所以是两个字节

> Java 每种基础数据类型所占存储空间大小是不变的

### 1.2.2 Java泛型？类型擦除？常用通配符?

java泛型是JDK5中新特性，泛型是 允许程序员在编译时检测到非法的类型，泛型的本质是参数化类型，也就是说，所操作的数据类型被指定为一个参数。

类型擦除就是泛型的特征，使我们无需考虑类型是什么。

**java的泛型是伪泛型，在java编译期间，所有泛型信息都会被擦掉**

例如，List<Object> 和 List<string> 在编译后都会变成List

### 1.2.3==和equals的区别

==：他的作用是半段两个对象的地址是否相等，即判断两个对象是不是同一个对象（基本数据类型比较的是值，引用数据类型比较的是内存地址）

> java只有值传递，所以，对于==来说，不管是比较基本数据类型还是引用数据类型，其本质都是比较值，只不过一个是比较真正的值，另一个比较的是对象的地址。

equals()：他的作用也是判断两个对象是否相等，不能用于比较基本数据类型，equals方法存在于Object中，在Object中也是比较两个变量的地址是否相等，但在某些Object的子类中，例如string中，重写了equals方法，所以在string中，equals方法比较的是两个字符串的值是否相等，而并非是否是两个相同的对象

- 当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。 

- String a = new String("ab"); 该句代码，创建了一个或两个对象

  一个是引用对象（a），在栈中new 一个引用变量

  一个是在常量池中（“ab”），创建ab这个字符串变量在堆中，但如果ab这个字符串常量已经存在，则不需要再创建，直接将ab这个字符串对象的地址引用给a即可。

### 1.2.4hashCode与equals

如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等,对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。**因此，equals 方法被覆盖过，则 `hashCode` 方法也必须被覆盖。**

## 1.3 基本数据类型

### 1.3.1自动装箱与拆箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

### 1.3.2 8种基本类型的包装类和常量池

**Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。**

Float，Double 并没有实现常量池技术

## 1.4 方法

### 1.4.1 Java中只有按值传递

**Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。**

### 1.4.2 重载和重写的区别

重载：同样一个方法可以根据输入数据的不同，做出不同的处理

重写：当子类继承父类的相同方法时，想要做出有别于父类的相应是，就需要重写父类方法

重写：

1. 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
3. 构造方法无法被重写

综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变

### 1.4.3 深拷贝与浅拷贝

1. **浅拷贝**：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。

# Java面向对象

## 2.1类和对象

### 2.1.1 面向对象和面向过程的区别

- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**
- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。

### 2.1.2 构造器 Constructor 是否可被override？

Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。

### 2.1.3 在java中定义一个无参构造且不做任何事的作用

Java 在执行子类构造方法之前，需要调用父类的构造方法，如果想要执行子类构造方法时，父类构造方法无法对其造成影响，则在父类中添加一个无参构造且不做任何事。

### 2.1.4 创建一个对象用什么运算符？对象尸体与对象引用有何不同？

new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。

### 2.1.5 在调用子类构造方法之前会先调用福利无参构造，其目的是？

帮助子类做初始化工作

## 2.2面向对象的三大特征

### 2.2.1 封装

封装是指把对象的属性隐藏在对象内部，不允许外部对象直接访问对象的内部信息，而是靠一些可以被外界访问的属性来操作。

### 2.2.2 继承

继承是使用已存在的类的定义作为基础建立新的类的技术，新类的定义可以增加新的数据和新的功能，可以快速的创建新的类，可以提高代码的的重用，程序的可维护性，提高开发效率。

### 2.2.3 多态

多态，表示一个对象具有多种的状态，具体表现为弗雷德引用指向子类的实例

多态的特点：

1.对象类型和引用类型之间具有继承/实现（接口）的关系。

2.引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定

3.多态不能调用“只在子类中存在但在父类中不存在”的方法

4.如果子类重写了父类的方法，真正执行的额是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的就是父类的方法

## 2.3修饰符

### 2.3.1 在一个静态方法内调用一个非静态成员为什么是非法的？

由于静态方法可以不通过对象调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

### 2.3.2 静态方法好实例方法有何不同

1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。

## 2.4.其他

### 2.4.1 String StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的

> String 类的实现改用byte数组存储字符串

```java
private final byte[] value
```

因为使用了final关键字来修饰字符数组来保存字符串，所以String对象是不可变的。

StringBuffer 与 StringBuilder 都继承自 AbstractStringBuilder 类，在AbstractStringBuilder 中也是使用字符数组保存字符串，但是没有用final关键字修饰，所以两种对象都是可变的。

> 内存

所以，当需要进行字符串的修改时，使用string比使用sbf和sbd更消耗内存资源，因为还要在常量池中建一个新的字符串对象。而另两种则不用。

> 线程安全

String中的对象是不可变的，可以理解为常量，线程安全。

sbf对方法加了同步锁（对调用的方法加了同步锁）所以线程安全

sbd并没有，所以线程不安全

> 性能

String 每次改变时，都会生成一个新的string对象，然后将指针指向新的string对象，所以效率不高

sbf由于有锁，效率比String高，但比sbd低，但只低百分之10-15，线程安全

sbd无锁，效率最高，但线程不安全

> 总结

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

### 2.4.2 Object 类的常见方法总结

```java

public final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。

public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。
public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。

protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。

public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。

public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。

public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。

public final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。

public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。

public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念

protected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作
```

