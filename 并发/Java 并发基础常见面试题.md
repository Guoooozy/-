# Java 并发基础常见面试题

## 1.什么是线程和进程？

### 1.1.何为进程

进程是程序一次执行的过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建运行到消亡的过程。

在Java中，当我们启动main函数时，就是启动了一个JVM的进程，而main函数所在的线程就是这个进程中的一个线程，也叫主线程

### 1.2.何为线程

线程与进程相似，但线程是一个比进程更小的执行单位，一个进程在执行过程中可以产生多个线程。与进程不同的事同类的多个线程共享进程的`堆`和`方法区资源`，但每个线程有自己的`程序计数器`

## 2.请简要描述线程和进程的关系，区别和优缺点？

### 2.1线程和进程的关系

一个进程可以有多个线程，多个线程共享进程的堆和方法区（元空间）资源，但是每个线程有自己的程序计数器，虚拟机栈和本地方法栈。

### 2.2程序计数器为什么是私有的

程序计数器的作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制.
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候，能够知道该线程上次运行到哪了。

所以程序计数器私有主要是为了线程切换后你呢个恢复到正确的执行位置。

### 2.3.虚拟机栈和本地方法栈为什么是私有的？

- 虚拟机栈：Java方法在执行的时候，会创建一个栈帧用于存储局部变量表，操作数栈，常量池引用等，从方法调用至方法执行完的过程，就对应着一个个的栈帧在Java虚拟机栈中入栈和出栈的过程
- 本地方法栈：和虚拟机栈相似，区别是：虚拟机栈为Java方法服务，而本地方法栈为Native方法服务，在HotSpot中和Java虚拟机栈合二为一

所以，为了保证县城中局部变量不被别的线程访问，虚拟机栈和本地方法栈都是线程私有的。

### 2.4一句话了解堆和方法区

堆和方法区是所有线程共享的资源，堆是进程中最大的一块内存，存放新创建的对象（几乎所有对象都在这里分配内存），方法区主要用于存放已被加载类的类信息，常量，静态变量，即时编译器编译后的代码等数据

## 3.说说并发和并行的关系

- 并发：同一时间段，多个任务都在执行（实践单位内不一定同时执行）
- 并行：单位时间内，多个任务同时执行

## 4.为什么要使用多线程？

总体上来说：

- **从计算机底层上来说**：线程是轻量级的进程，切换和调度的成本低，多核CPU使线程同时运行，减少了线程上下文切换的开销（减少开销）
- **从互联网发展趋势来说**：现如今的系统需要百万级甚至千万级的并发量，而多线程并发编程是开发高并发系统的基础，利用好多线程可以大大提高系统整体的并发能力以及性能

再深入到计算机底层来探讨：

- **单核时代：** 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
- **多核时代:** 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

## 5.使用多线程会带来什么问题？

内存泄漏，死锁，线程不安全

## 6.线程的生命周期和状态？

- new   			初始状态，线程被构建，但是还没有调用start方法
- runnbale       运行状态，Java线程将操作系统中的就绪和运行两种状态笼统的成为运行中
- blocked         阻塞，表示线程阻塞于锁
- waiting          等待状态，进入该状态表示当前线程需要等待其他线程做出特定动作（通知或中断）
- time_waiting 超时等待状态，该状态不同于waiting，该状态可以在制定时间自行返回
- terminated    终止状态，表示当前线程已经执行完毕

线程创建之后将处于new（新建）状态，调用start()方法后开始运行，线程处于ready（可运行）状态。可运行状态的线程获得了CPU时间片后，处于running状态

## 7.什么是上下文切换

CPU为每个线程分配时间片并轮转的形式，当一个线程的时间片用玩的时候就会重新处于就绪状态让给其他线程使用，这个过程就是一次上下文切换

当前任务在执行文CPU时间片切换到另一个任务之前会先保存自己的状态，一遍下一次再切换回这个任务的时候，可以再加载这个任务的状态，**任务从保存到再加载的过程就是一次上下文切换**

## 8.什么是死锁？如何避免死锁？

### 8.1认识线程死锁

多个线程被同时阻塞，他们中的一个或者全部都在等待某个资源被释放，由于线程被无限期的阻塞，因此程序不能正常终止，比如线程A持有资源2，线程B持有资源1，他们都想申请到对方的资源，这时两个资源就会互相等待而进入死锁状态。

产生死锁的四个条件：

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### 8.2 如何避免线程死锁？

我上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：

1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
2. **破坏请求与保持条件** ：一次性申请所有的资源。
3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

## 9.sleep()方法和wait()方法区别和共同点？

1. 最主要区别：**sLeep方法没有释放锁，而wait方法释放了锁**
2. 两者都可以暂停线程的执行
3. wait通常被用于线程间的交互/通信，sleep通常被用于暂停执行
4. wait方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify或notifyAll方法。sleep方法执行后，线程会自动苏醒，可以使用wait（long timeout）超时后，线程会自动苏醒

## 10.为什么调用start方法会执行run方法？为什么不直接调用run方法

new 一个 Thread，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结： 调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

## 11.